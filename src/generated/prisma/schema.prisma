// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id             String    @id @default(cuid())
  email          String    @unique
  name           String?
  emailVerified  DateTime?
  image          String?
  hashedPassword String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Subscription and billing
  subscriptionTier   SubscriptionTier @default(FREE)
  subscriptionId     String?
  customerId         String? // Stripe customer ID
  subscriptionEndsAt DateTime?

  // Usage tracking
  monthlyRoasts  Int      @default(0)
  totalRoasts    Int      @default(0)
  lastRoastReset DateTime @default(now())

  // Relations
  accounts            Account[]
  sessions            Session[]
  documents           Document[]
  usageRecords        UsageRecord[]
  invoices            Invoice[]
  llmConversations    LLMConversation[]
  sharedAnalyses      SharedAnalysis[]
  analyses            Analysis[]
  resumeOptimizations ResumeOptimization[]
  coverLetters        CoverLetter[]
  optimizedResumes    OptimizedResume[]
  extractedResumes    ExtractedResume[]

  @@map("users")
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?  @db.Text
  access_token      String?  @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?  @db.Text
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Document {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // File information
  filename     String
  originalSize Int
  fileHash     String @unique // SHA-256 hash to detect duplicates
  mimeType     String

  // Extraction data
  extractedText  String @db.Text
  wordCount      Int
  pageCount      Int
  aiProvider     String // "anthropic" or "openai"
  extractionCost Float  @default(0) // Cost in USD

  // Metadata from AI
  summary  String?  @db.Text
  sections String[] // JSON array of sections
  images   String[] @default([]) // Base64 encoded PDF page images

  // Processing info
  processedAt    DateTime @default(now())
  processingTime Int // milliseconds

  // Relations
  user                User?                @relation(fields: [userId], references: [id], onDelete: SetNull)
  usageRecords        UsageRecord[]
  llmConversations    LLMConversation[]
  analyses            Analysis[]
  resumeOptimizations ResumeOptimization[]
  coverLetters        CoverLetter[]
  optimizedResumes    OptimizedResume[]
  extractedResumes    ExtractedResume[]

  @@index([fileHash])
  @@index([userId])
  @@map("documents")
}

model UsageRecord {
  id          String      @id @default(cuid())
  userId      String
  documentId  String
  action      UsageAction
  cost        Float       @default(0) // Cost in USD
  creditsUsed Int         @default(1)
  createdAt   DateTime    @default(now())

  // Billing period
  billingMonth String // Format: "2025-01"

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([userId, billingMonth])
  @@index([createdAt])
  @@map("usage_records")
}

model Invoice {
  id     String @id @default(cuid())
  userId String

  // Billing details
  amount   Float // Total amount in USD
  currency String        @default("USD")
  status   InvoiceStatus @default(PENDING)

  // Billing period
  billingPeriodStart DateTime
  billingPeriodEnd   DateTime

  // Stripe integration
  stripeInvoiceId String? @unique
  stripePaymentId String?

  // Metadata
  itemCount   Int // Number of roasts in this invoice
  generatedAt DateTime  @default(now())
  paidAt      DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@map("invoices")
}

model LLMConversation {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Conversation metadata
  type       ConversationType // RESUME_ANALYSIS, JOB_EXTRACTION, COVER_LETTER, etc.
  title      String? // Optional title for the conversation
  documentId String? // Related document if applicable

  // Provider and model info
  provider String // "anthropic", "openai", etc.
  model    String // "claude-3-sonnet", "gpt-4", etc.

  // Costs and tokens
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD

  // Timing
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  // Status
  status       ConversationStatus @default(ACTIVE)
  errorMessage String?

  // Relations
  user                User?                @relation(fields: [userId], references: [id], onDelete: SetNull)
  document            Document?            @relation(fields: [documentId], references: [id], onDelete: SetNull)
  messages            LLMMessage[]
  analyses            Analysis[]
  resumeOptimizations ResumeOptimization[]
  coverLetters        CoverLetter[]
  optimizedResumes    OptimizedResume[]
  extractedResumes    ExtractedResume[]

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("llm_conversations")
}

model LLMMessage {
  id             String @id @default(cuid())
  conversationId String

  // Message content
  role    MessageRole // USER, ASSISTANT, SYSTEM
  content String      @db.Text

  // Token usage for this specific message
  inputTokens  Int? // Tokens in the input
  outputTokens Int? // Tokens in the output
  totalTokens  Int? // Total tokens for this message

  // Cost for this specific message
  cost Float @default(0) // Cost in USD

  // Metadata
  messageIndex   Int // Order in conversation (0, 1, 2, ...)
  processingTime Int? // Response time in milliseconds

  // AI-specific metadata
  finishReason String? // "stop", "length", "content_filter", etc.
  temperature  Float? // Temperature used for generation
  maxTokens    Int? // Max tokens requested

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  conversation LLMConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([conversationId, messageIndex])
  @@index([conversationId])
  @@index([createdAt])
  @@map("llm_messages")
}

model Analysis {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Analysis metadata
  title      String // User-provided or auto-generated title
  documentId String? // Related document if applicable

  // Input data
  jobDescription String  @db.Text // The job description used for analysis (kept for backward compatibility)
  jobSummaryId   String? // Reference to summarized job description
  resumeText     String  @db.Text // The resume text that was analyzed

  // Analysis results
  analysisData String @db.Text // JSON string of the complete analysis results
  overallScore Int? // Overall score for quick access

  // AI metadata
  provider       String // "anthropic", "openai", etc.
  model          String // "claude-3-sonnet", "gpt-4", etc.
  conversationId String? // Link to LLM conversation if available

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)
  document            Document?              @relation(fields: [documentId], references: [id], onDelete: SetNull)
  conversation        LLMConversation?       @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  jobSummary          JobDescriptionSummary? @relation(fields: [jobSummaryId], references: [id], onDelete: SetNull)
  resumeOptimizations ResumeOptimization[]
  coverLetters        CoverLetter[]
  optimizedResumes    OptimizedResume[]
  extractedResumes    ExtractedResume[]

  @@index([userId])
  @@index([createdAt])
  @@index([overallScore])
  @@index([jobSummaryId])
  @@map("analyses")
}

model ResumeOptimization {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Input references
  analysisId String? // Reference to the analysis that triggered this optimization
  documentId String? // Reference to the original document

  // Input data
  jobDescription String  @db.Text // The job description used for optimization (kept for backward compatibility)
  jobSummaryId   String? // Reference to summarized job description
  resumeText     String  @db.Text // The original resume text
  templateId     String // Template used for optimization

  // Optimization results
  extractedData           String   @db.Text // JSON string of the extracted/optimized resume data
  optimizedResume         String   @db.Text // The final optimized resume HTML/content
  optimizationSuggestions String[] // Array of optimization suggestions applied
  atsScore                Int? // ATS compatibility score
  keywordsMatched         String[] // Keywords that were successfully matched

  // AI metadata
  provider       String // "anthropic", "openai", etc.
  model          String // "claude-3-sonnet", "gpt-4", etc.
  conversationId String? // Link to LLM conversation if available

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)
  analysis     Analysis?              @relation(fields: [analysisId], references: [id], onDelete: SetNull)
  document     Document?              @relation(fields: [documentId], references: [id], onDelete: SetNull)
  conversation LLMConversation?       @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  jobSummary   JobDescriptionSummary? @relation(fields: [jobSummaryId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([analysisId])
  @@index([createdAt])
  @@index([atsScore])
  @@index([jobSummaryId])
  @@map("resume_optimizations")
}

model SharedAnalysis {
  id     String @id // Custom ID for sharing
  userId String

  // Analysis content
  analysisData String  @db.Text // JSON string of analysis results
  settings     String? @db.Text // JSON string of share settings

  // Sharing metadata
  viewCount Int      @default(0)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("shared_analyses")
}

model JobDescriptionSummary {
  id String @id @default(cuid())

  // Content hashing for deduplication
  contentHash  String @unique // SHA-256 hash of the original job description
  originalText String @db.Text // Original job description

  // Summary data
  summary         String   @db.Text // Summarized version
  keyRequirements String[] // Extracted key requirements
  companyName     String? // Extracted company name
  jobTitle        String? // Extracted job title
  location        String? // Extracted location
  salaryRange     String? // Extracted salary range if mentioned

  // AI metadata
  provider String // "openai", "anthropic", etc.
  model    String // Model used for summarization

  // Usage tracking
  usageCount Int @default(1) // How many times this summary has been used

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Timestamps
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  lastUsedAt DateTime @default(now())

  // Relations
  analyses            Analysis[]
  resumeOptimizations ResumeOptimization[]
  coverLetters        CoverLetter[]
  optimizedResumes    OptimizedResume[]

  @@index([contentHash])
  @@index([createdAt])
  @@index([usageCount])
  @@map("job_description_summaries")
}

model CoverLetter {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Content and metadata
  content   String @db.Text // The generated cover letter content
  tone      String @default("professional") // professional, enthusiastic, conversational
  wordCount Int    @default(0)

  // Input references
  analysisId   String? // Reference to the analysis that triggered this
  documentId   String? // Reference to the resume document
  jobSummaryId String? // Reference to the job description summary

  // Content hashing for deduplication (based on resume + job + tone)
  contentHash String @unique // SHA-256 hash for deduplication

  // AI metadata
  provider       String // "openai", "anthropic", etc.
  model          String // Model used for generation
  conversationId String? // Link to LLM conversation if available

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Usage tracking
  usageCount Int      @default(1) // How many times this has been accessed
  lastUsedAt DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)
  analysis     Analysis?              @relation(fields: [analysisId], references: [id], onDelete: SetNull)
  document     Document?              @relation(fields: [documentId], references: [id], onDelete: SetNull)
  jobSummary   JobDescriptionSummary? @relation(fields: [jobSummaryId], references: [id], onDelete: SetNull)
  conversation LLMConversation?       @relation(fields: [conversationId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([analysisId])
  @@index([documentId])
  @@index([jobSummaryId])
  @@index([contentHash])
  @@index([createdAt])
  @@index([usageCount])
  @@map("cover_letters")
}

model OptimizedResume {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Content and metadata
  content                 String   @db.Text // The optimized resume content (HTML/markdown)
  extractedData           String   @db.Text // JSON string of structured resume data
  templateId              String // Template used for optimization
  atsScore                Int? // ATS compatibility score
  keywordsMatched         String[] // Keywords that were successfully matched
  optimizationSuggestions String[] // Array of optimization suggestions applied

  // Input references
  analysisId        String? // Reference to the analysis that triggered this
  documentId        String? // Reference to the original resume document
  jobSummaryId      String? // Reference to the job description summary
  extractedResumeId String? // Reference to the extracted resume data

  // Content hashing for deduplication (based on resume + job + template)
  contentHash String @unique // SHA-256 hash for deduplication

  // AI metadata
  provider       String // "openai", "anthropic", etc.
  model          String // Model used for optimization
  conversationId String? // Link to LLM conversation if available

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Usage tracking
  usageCount Int      @default(1) // How many times this has been accessed
  lastUsedAt DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user            User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)
  analysis        Analysis?              @relation(fields: [analysisId], references: [id], onDelete: SetNull)
  document        Document?              @relation(fields: [documentId], references: [id], onDelete: SetNull)
  jobSummary      JobDescriptionSummary? @relation(fields: [jobSummaryId], references: [id], onDelete: SetNull)
  conversation    LLMConversation?       @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  extractedResume ExtractedResume?       @relation(fields: [extractedResumeId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([analysisId])
  @@index([documentId])
  @@index([jobSummaryId])
  @@index([extractedResumeId])
  @@index([contentHash])
  @@index([createdAt])
  @@index([usageCount])
  @@index([atsScore])
  @@map("optimized_resumes")
}

model ExtractedResume {
  id     String  @id @default(cuid())
  userId String? // Null for anonymous users

  // Input references
  documentId String? // Reference to the original resume document
  analysisId String? // Reference to the analysis that triggered this extraction

  // Content hashing for deduplication (based on resume text)
  contentHash String @unique // SHA-256 hash of the resume text for deduplication
  resumeText  String @db.Text // The original resume text that was extracted

  // Extracted data
  extractedData String @db.Text // JSON string of the structured resume data

  // AI metadata
  provider       String // "anthropic", "openai", etc.
  model          String // Model used for extraction
  conversationId String? // Link to LLM conversation if available

  // Costs and performance
  totalTokensUsed Int   @default(0)
  totalCost       Float @default(0) // Cost in USD
  processingTime  Int? // Processing time in milliseconds

  // Usage tracking
  usageCount Int      @default(1) // How many times this has been accessed
  lastUsedAt DateTime @default(now())

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user             User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  document         Document?         @relation(fields: [documentId], references: [id], onDelete: SetNull)
  analysis         Analysis?         @relation(fields: [analysisId], references: [id], onDelete: SetNull)
  conversation     LLMConversation?  @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  optimizedResumes OptimizedResume[] // Optimized resumes based on this extraction

  @@index([userId])
  @@index([documentId])
  @@index([analysisId])
  @@index([contentHash])
  @@index([createdAt])
  @@index([usageCount])
  @@map("extracted_resumes")
}

// Enums
enum SubscriptionTier {
  FREE
  PLUS
  PREMIUM
}

enum UsageAction {
  EXTRACT_PDF
  ROAST_ANALYSIS
  COVER_LETTER_GENERATION
  RESUME_OPTIMIZATION
  RESUME_EXTRACTION
}

enum InvoiceStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

enum ConversationType {
  RESUME_ANALYSIS
  JOB_EXTRACTION
  COVER_LETTER_GENERATION
  PDF_EXTRACTION
  RESUME_EXTRACTION
  GENERAL_CHAT
  CHATBOT_SUPPORT
}

enum ConversationStatus {
  ACTIVE
  COMPLETED
  FAILED
  CANCELLED
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}
